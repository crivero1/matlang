%To avoid nasty technical stuff, we will try to connect with circuits:
%\begin{itemize}
%\item Upper bound (AC?)
%\item Lower bound (transitive closure?)
%\end{itemize}

% OTHER IDEAS ABOUT PRESENTATION
%OPTION 1:
% LINK WITH TMS FIRST (NO CIRCUITS)!
% NOW INTRODUCE CIRCUITS
% USING THIS LINK, ASSUME THAT FOR EVALUATING A CIRCUIT INFO ABOUT A GATE IS AVAILABLE THROUGH AN EFFICIENT TM (NO UNIFORMITY)
% STATE THE RESULT ABOUT SIMULATION OF A SINGLE CIRCUIT IN ML
% NOW ESTABLISH A LINK WITH UNIFORM CIRCUITS -- JUST SAY THAT WE ALREADY KNOW HOW TO SIMULATE THE MACHINE, SO ALL GOOD
% NOW GO IN THE OTHER DIRECTION WITH A MORE EXPRESSIVE CLASS OF CIRCUITS

%OPTION 2:
% DEFINE ARITHMETIC CIRCUITS AND EVALUATE A SINGLE CIRCUIT
% LINK WITH TMS WHEN ASSUMING THAT TMS ARE GIVEN FOR CIRCUIT DATA
% ASSUME THAT FOR EVALUATING A CIRCUIT INFO ABOUT A GATE IS AVAILABLE THROUGH AN EFFICIENT TM (NO UNIFORMITY)
% NOW GO IN THE OTHER DIRECTION WITH A MORE EXPRESSIVE CLASS OF CIRCUITS
% NOW ESTABLISH A LINK WITH UNIFORM CIRCUITS


In this section we explore the expressive power of $\langfor$. Given that \langfor\ expressions compute functions over matrices whose entries are not only boolean, but can in fact be arbitrary elements from $\RR$, a natural candidate for comparison is the class of arithmetic circuits \cite{allender}. As we show in the remainder of this section, \langfor\ captures the expressive power of arithmetic circuits. %To show this result, we first recall the definition of arithmetic circuits.
%
%In order to derive this result, we first look at the connection of \langfor\ and Turing machines. When observing a \langfor\ expression over some schema, perhaps the most crucial characteristic is the fact that depending on the instance, the number of iterations that a for loop does changes, as does the size of the matrix computed by our expression. This is analogous to how the number of steps a Turing machine takes changes depending on the input size, and gives some intuition on why \langfor\ expressions might be able to simulate Turing machines. Indeed, what we show is that \langfor\ expressions can actually  simulate Turing machines that use linear space and run in polynomial time. Formally, we prove the following.
%
%\begin{theorem}
%\label{th-tm-ml}
%Let $T$ be a Turing machine with $\ell$ read only input tapes, a work tape, and an output tape. 
%\end{theorem}
%
%Next we move to comparison with arithmetic circuits. 

We begin by recalling the definition of arithmetic circuits. 
An {\em arithmetic circuit} $\Phi$ over a set $X=\{x_1,\ldots,x_n\}$ of variables is a directed
acyclic labelled graph. The vertices of $\Phi$ are called {\em gates} and denoted by $g_1,\ldots,g_m$;
the edges in $\Phi$ are called {\em wires}. The children of a gate $g$ correspond to all gates
$g'$ such that $(g,g')$ is an edge. The parents of $g$ correspond to all gates $g'$ 
such that $(g',g)$ is an edge. The {\em in-degree}, or a {\em fan-in}, of a gate $g$ refers to its number of children, and 
the {\em out-degree} to its number of parents. We will not assume any restriction on the in-degree of a gate, and will thus consider circuits with unbounded fan-in. Gates with in-degree $0$ are called {\em input gates}
and are labelled by either a variable in $X$ or a constant $0$ or $1$. All other gates
are labelled by either $+$ or $\times$, and are referred to as {\em sum gates} or {\em product gates}, respectively.
Gates with out-degree $0$ are called {\em output gates}. When talking about arithmetic circuits, one usually focuses on circuits with $n$ input gates and a single output gate.

The {\em size} of $\Phi$, denoted by $|\Phi|$, is its number of gates and wires. The {\em depth} of $\Phi$, denoted
by $\mathsf{depth}(\Phi)$, is the length of the longest directed path from the any output gate to any of the input gates. The {\em degree} of a gate is defined inductively: a leaf node has degree 1, a plus node has a degree equal to the maximum of  degrees of its children, and a product node has a degree equal to the sum of the degrees of its children. When $\Phi$ has a single output gate, the {\em degree} of $\Phi$, denoted by $\mathsf{degree}(\Phi)$, is defined as the degree of its output gate. If $\phi$ has a single output gate and its input gates take values from $\RR$, then $\Phi$ corresponds to a polynomial in $\RR[X]$ in a natural way. In this case, the {degree} of $\Phi$ equals the degree of the polynomial corresponding to $\Phi$.
If $v_1,\ldots ,v_n$ are values in $\RR$, then we define the result of the circuit on this input as the value computed by the corresponding polynomial, and denote this value with $\Phi_k(v_1,\ldots ,v_k)$.

%\domagoj{Should we already present the result without talking about uniformity?}

% MAYBE OVERCOMPLICATING
%In order to talk about efficient evaluation of arithmetic circuits in terms of complexity classes defined by Turing machines, we need a notion of uniformity of circuit families. An {\em arithmetic circuit family} is a set of arithmetic circuits $\{\Phi_n\mid n=1,2,\ldots\}$ where $\Phi_n$ has $n$ input variables. An arithmetic circuit family is {\em uniform} if there exist \logspace-Turing machines\footnote{There are several versions of this definition that give a different amount of resources to the Turing machine. See \cite{allender} for an in-depth discussion on the subject.} $M_1$ and $M_2$, such that:
%\begin{itemize}
%\item On input $1^n$, the machine $M_1$ returns an encoding of the arithmetic circuit $\Phi_n$ for each $n$;
%\item On input $1^n$, and an encoding of a gate $g$, the machine $M_2$ outputs the relevant information about $g$ (e.g. whether it is a sum or a product gate, the list of its children, whether it is an output gate, etc.).
%\end{itemize}
%
%The idea here is that the machine $M_1$ gives an overview of the circuit itself, while the machine $M_2$ allows us to efficiently evaluate the circuits by traversing the circuit graph in a depth-first fashion, starting from the output node. We observe that uniform arithmetic circuit families are necessarily of polynomial size.
%
%SHOULD EXPLAIN BRIEFLY HOW TO EVALUATE A CIRCUIT!

%In order to talk about efficient evaluation of arithmetic circuits in terms of complexity classes defined by Turing machines, we need a notion of uniformity of circuit families. 
In order to talk about efficient evaluation of arithmetic circuits, we need a way to compute their output algorithmically. Namely, we need a way to access their components such as the children of some gate, the value of an input gate, the operation  carried out by the gate, etc. The most general way to do this is via Turing machines. Additionally, this will allow us to handle inputs of arbitrary size, similarly as when working with Turing machines. This idea is captured by the notion of uniform circuit families. 

An {\em arithmetic circuit family} is a set of arithmetic circuits $\{\Phi_n\mid n=1,2,\ldots\}$ where $\Phi_n$ has $n$ input variables and a single output variable. An arithmetic circuit family is {\em uniform} if there exists a \logspace-Turing machine\footnote{There are several versions of this definition that give a different amount of resources to the Turing machine. See \cite{AllenderJMV98} for an in-depth discussion on the subject.}, which on input $1^n$, returns an encoding of the arithmetic circuit $\Phi_n$ for each $n$.
% Additionally, we assume that there is a \logspace-machine which, when started on input $1^n$, and an encoding of a gate $g$, outputs the relevant information about $g$ in $\Phi_n$ (e.g. whether it is a sum or a product gate, the list of its children, whether it is an output gate, etc.).
We observe that uniform arithmetic circuit families are necessarily of polynomial size. %, however, their degree can grow exponentially. A circuit family $\{\Phi_n\mid n=1,2,\ldots\}$ is said to be of polynomial degree if $\mathsf{degree}(\Phi_n)\in O(p(n))$, for some polynomial $p(n)$. Similarly, a circuit family is of logarithmic depth, whenever $\mathsf{depth}(\Phi_n)\in O(logn)$. We can now show that \langfor\ subsumes uniform arithmetic circuit families that are of polynomial degree and logarithmic depth. 
Another important parameter is the circuit depth. A circuit family is of logarithmic depth, whenever $\mathsf{depth}(\Phi_n)\in O(logn)$. We can now show that \langfor\ subsumes uniform arithmetic circuit families that are of logarithmic depth. 

%\domagoj{The thing about the second machine is crucial, but it might be a bit confusing here, as we only need it to explain how one actually computes the output of a circuit. Because of this I'm thinking of maybe presenting the connection without uniformity.}

\begin{theorem}
\label{th-circuits-ml}
For any uniform arithmetic circuit family $\{\Phi_n\mid n=1,2,\ldots\}$ of logarithmic depth there is a \langfor\ schema $\Sch$ and an expression $e_\Phi$ using a matrix variable $v$, with $\ttype(v)=(\alpha,1)$ and $\ttype(e) = (1,1)$, such that for any input $v_1,\ldots ,v_n$ to the circuit $\Phi_n$:
\begin{itemize}
\item If $\I = (\dom,\conc)$ is a \lang\ instance such that $\dom(\alpha) = n$ and $\conc(v) = (v_1 \ldots v_n)^*$
\item Then $\sem{e}{\I} = \Phi_n(v_1,\ldots ,v_n)$.
\end{itemize}
\end{theorem}
It is important to note that the expression $e_\Phi$ does not change depending on the input size, meaning that it is uniform in the same sense as the circuit family being generated by a single Turing machine. The different input sizes for a \langfor\ instance are handled by the typing mechanism of the language. 


{\em Proof idea.}
The expression $e_\Phi$ on input $(v_1,\ldots ,v_n)^*$ basically simulates depth-first evaluation of the arithmetic circuit $\Phi_n$. 
In order to do this, we consider an algorithm for evaluating $\Phi_n$ on input $(v_1,\ldots ,v_n)$ that maintains  two stacks: the gates-stack that tracks the current gate being evaluated, and the values-stack that stores the value that is being computed for this gate. The idea behind having two stacks is that whenever the number of items on the gates-stack is higher by one than the number of items on the values-stack, we know that we are processing a fresh gate, and we have to initialize its current value (to 0 if it is a plus gate, and to 1 if it is a product gate), and push it to the values-stack. We then proceed by processing the children of the head of the gates-stack one by one, and aggregate the results using sum if we are working with a plus gate, and by using product otherwise. 

The question that remains to answer is how do we access the information about each gate we are processing, such as whether it is a plus or a product gate, the list of its children, or whether it is an input gate? This is where the uniformity condition comes in handy. Namely, we know that we can generate the circuit $\Phi_n$ with a \logspace-Turing machine $M_\Phi$ by running it on the input $1^n$. Using this machine, we can in fact compute all the information needed to run the two-stack algorithms described above. 

For instance, we can construct a \logspace\ machine that checks, given two gates $g_1$ and $g_2$ whether $g_2$ is a child of $g_1$. Similarly, we can construct a machine that, given $g_1$ and $g_2$ tells us whether $g_2$ is the final child of $g_1$, or the one that produces the following child of $g_1$ (according to the ordering given by the machine $M_\Phi$). Defining these machines based of $M_\Phi$ is similar to the algorithm for the composition of two \logspace\ transducers, and is based on "hard-coding" the values such as $g_1$ and $g_2$ into the machine $M_\Phi$. An important detail here is also that these computations can be carried out using only linear amount of space on the output tape. We remark that this, more operational, definition of arithmetic circuits is quite commonly used when evaluating them \cite{allender}.

In order to access this information in \langfor, we can actually show that any polynomial-time Turing machine that on input $w_1,\ldots ,w_\ell\in \{0,1\}^n$ runs in linear space, and produces an output $w\in \{0,1\}$ of size $n$, can in fact be simulated using a \langfor\ expression that, when interpreted n an instance assigning $w_1,\ldots ,w_n$ to its variables, produces a vector of size $n\times 1$ corresponding to $w$.

To simulate the circuit evaluation algorithm that uses two stacks, in \langfor\ we can use a binary matrix of size $n\times n$, where $n$ is the number of inputs. The idea here is that each gate, encoded as a binary number, is represented by the positions $1\ldots n-3$ of each row. The remaining three columns are reserved for the values-stack, the number of elements on the gates stack, and the number of elements on the values stack, respectively. The number of elements is encoded as a canonical vector of size $n$. Here we crucially depend on the fact that the circuit is of logarithmic depth, and therefore the size of the two stacks is bounded by $n$ (apart from the portion before the asymptotic bound kicks-in, which can be hard coded into the formula). Similarly, given that the circuits are of polynomial size, we can assume that gate ids can be encoded into $n-3$ bits.

This matrix is then updated in the same way as the two-stack algorithm. It processes gates one by one, and using the order relation determines whether we have more elements on the gates stack. In this case, a new value is added to the values stack (0 if the gate is a plus gate, and 1 otherwise), and the process continues. Information about the next child, last child, or input value, are obtained using the expression which simulates the Turing machine generating this data about the circuit. Given the size of the circuit is polynomial, say $n^k$, we can initialize the matrix with the output gate only, and run the simulation of the two-stack algorithm for $n^k$ steps (by iterating $k$ times over size $n$ canonical vectors). After this, the value in position  $(1,n-2)$ (the top of the values stack) holds the final results. \qed

\smallskip

Arithmetic circuits are used to compute functions over real numbers. Formally, a circuit family $(\Phi_n)_n$ computes a function $f:\bigcup \mathbb{R}^n\mapsto\mathbb{R}$, if for any $v_1,\ldots v_n\in \mathbb{R}$ it holds that $\Phi_n(v_1,\ldots ,v_n) = f(v_1,\ldots ,v_n)$. While Theorem \ref{th-circuits-ml} gives us an idea on how to simulate arithmetic circuits, it does not tell us which classes of functions over real numbers can be computed by \langfor\ expressions. In order to answer this question, we need to look at circuit families of bounded degree. 

A circuit family $\{\Phi_n\mid n=1,2,\ldots\}$ is said to be of polynomial degree if $\mathsf{degree}(\Phi_n)\in O(p(n))$, for some polynomial $p(n)$. Note that polynomial size circuit families are not necessarily of polynomial degree. An easy corollary of Theorem \ref{th-circuits-ml} tells us that all functions computed by uniform family of circuits of polynomial degree and logarithmic depth can be simulated using \langfor\ expressions. However, we can actually drop the restriction on circuit depth due to a result by Allender et. al. \cite{AllenderJMV98} which says that any function computed by a uniform circuit family of polynomial degree (and polynomial depth), can also be computed by a uniform circuit family of logarithmic depth. Using this fact, we can conclude the following:

%An important observation here is that, due to the depth reduction result for arithmetic circuits \cite{AllenderJMV98}, we can in fact show a version of Theorem \ref{th-circuits-ml} with no condition about the circuit depth. To formalize this, we need to define the class of functions computed by arithmetic circuits. Formally, a circuit family $(\Phi_n)_n$ computes a function $f:\bigcup \mathbb{R}^n\mapsto\mathbb{R}$, if for any $v_1,\ldots v_n\in \mathbb{R}$ it holds that $\Phi_n(v_1,\ldots ,v_n) = f(v_1,\ldots ,v_n)$. Given that any function computed by 

\begin{corollary}
\label{cor-circ-ml}
For any function $f$ computed by a uniform family of arithmetic circuits of polynomial degree, there is an equivalent \langfor\ formula $e_f$.
\end{corollary}

\domagoj{If needed the corollary can be merged into Theorem 6.1. I prefer it here to separate the degree vs. size discussion.}

Now that we know that arithmetic circuits can be simulated using \langfor\ expressions, it is natural to ask whether the same holds in the other direction. That is, we are asking whether for each \langfor\ expression $e$ over some schema $\Sch$ there is a uniform family of arithmetic circuits computing precisely the same result depending on the input size. In order to show this, we need to extend the 

EXTEND THE CIRCUITS...